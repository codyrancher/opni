syntax = "proto3";

package cortexops;

import "github.com/rancher/opni/internal/codegen/cli/cli.proto";
import "github.com/rancher/opni/internal/cortex/config/compactor/compactor.proto";
import "github.com/rancher/opni/internal/cortex/config/querier/querier.proto";
import "github.com/rancher/opni/internal/cortex/config/validation/limits.proto";
import "github.com/rancher/opni/pkg/apis/storage/v1/storage.proto";
import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

option go_package = "github.com/rancher/opni/plugins/metrics/apis/cortexops";
option (cli.generator) = {
  generate: true
};

// The CortexOps service contains setup and configuration lifecycle actions for the managed Cortex cluster.
service CortexOps {
  option (cli.command_group) = {
    use: "ops"
  };

  // Gets the current configuration of the managed Cortex cluster.
  rpc GetClusterConfiguration(google.protobuf.Empty) returns (ClusterConfiguration) {
    option (cli.command) = {
      use: "get-configuration";
    };
    option (google.api.http) = {
      get: "/configuration"
    };
  }

  // Updates the configuration of the managed Cortex cluster to match the provided configuration.
  // If the cluster is not installed, it will be configured and installed.
  // Otherwise, the already-installed cluster will be reconfigured.
  //
  // Note: some fields may contain secrets. The placeholder value "***" can be used to
  // keep an existing secret when updating the cluster configuration.
  rpc ConfigureCluster(ClusterConfiguration) returns (google.protobuf.Empty) {
    option (cli.command) = {
      use: "configure";
      // required_flags: ["mode", "storage.backend"];
    };
    option (google.api.http) = {
      post: "/configure"
      body: "*"
    };
  }

  // Gets the current status of the managed Cortex cluster.
  // The status includes the current install state, version, and metadata. If
  // the cluster is in the process of being reconfigured or uninstalled, it will
  // be reflected in the install state.
  // No guarantees are made about the contents of the metadata field; its
  // contents are strictly informational.
  rpc GetClusterStatus(google.protobuf.Empty) returns (InstallStatus) {
    option (cli.command) = {
      use: "status";
    };
    option (google.api.http) = {
      get: "/status"
    };
  }

  // Uninstalls the managed Cortex cluster.
  // Implementation details including error handling and system state requirements
  // are left to the cluster driver, and this API makes no guarantees about
  // the state of the cluster after the call completes (regardless of success).
  rpc UninstallCluster(google.protobuf.Empty) returns (google.protobuf.Empty) {
    option (cli.command) = {
      use: "uninstall";
    };
    option (google.api.http) = {
      post: "/uninstall"
    };
  }
}

enum InstallState {
  Unknown      = 0;
  NotInstalled = 1;
  Updating     = 2;
  Installed    = 3;
  Uninstalling = 4;
}

message InstallStatus {
  InstallState        state    = 1;
  string              version  = 2;
  map<string, string> metadata = 3;
}

enum DeploymentMode {
  // All components are together in a single process. Not recommended for production use.
  AllInOne = 0;
  // Components are distributed across multiple processes.
  HighlyAvailable = 1;
}

message ClusterConfiguration {
  // The deployment mode to use for Cortex.
  DeploymentMode      mode      = 1;
  storage.StorageSpec storage   = 2;
  GrafanaConfig       grafana   = 3;
  Workloads           workloads = 4;
  CortexConfig        cortex    = 5;
}

message Workloads {
  CortexWorkloadSpec distributor   = 1 [(cli.flag_set).default = {[type.googleapis.com/cortexops.CortexWorkloadSpec]: {replicas: 1}}];
  CortexWorkloadSpec ingester      = 2;
  CortexWorkloadSpec compactor     = 3;
  CortexWorkloadSpec storeGateway  = 4;
  CortexWorkloadSpec ruler         = 5;
  CortexWorkloadSpec queryFrontend = 6 [(cli.flag_set).default = {[type.googleapis.com/cortexops.CortexWorkloadSpec]: {replicas: 1}}];
  CortexWorkloadSpec querier       = 7;
  CortexWorkloadSpec purger        = 8 [(cli.flag_set).default = {[type.googleapis.com/cortexops.CortexWorkloadSpec]: {replicas: 1}}];
}

message CortexWorkloadSpec {
  // Number of replicas to run for this workload. Should be an odd number.
  int32 replicas = 1;
  // Any additional arguments to pass to Cortex.
  repeated string extraArgs = 2;
}

message CortexConfig {
  validation.Limits limits = 1 [(cli.flag_set) = {
    default: {
      [type.googleapis.com/validation.Limits]: {
        compactor_blocks_retention_period: {seconds: 2592000} /* 30 days */
        ingestion_rate: 600000
        ingestion_rate_strategy: "local"
        ingestion_burst_size: 1000000
        max_series_per_user: 0
        max_series_per_metric: 0
        max_global_series_per_user: 0
        max_global_series_per_metric: 0
        max_metadata_per_user: 0
        max_metadata_per_metric: 0
        max_global_metadata_per_user: 0
        max_global_metadata_per_metric: 0
        max_fetched_series_per_query: 0
      }
    }
  }];
  map<string, validation.Limits> tenantLimits = 2 [(cli.flag).skip = true];
  compactor.Config               compactor    = 3;
  querier.Config                 querier      = 4;
}

message GrafanaConfig {
  // Whether to deploy a managed Grafana instance.
  bool enabled = 1 [(cli.flag).default = "false"];

  // DNS name at which Grafana will be available in the browser.
  string hostname = 2;
}
