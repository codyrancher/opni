// Code generated by cli_gen.go DO NOT EDIT.
// source: github.com/rancher/opni/plugins/metrics/apis/cortexops/cortexops.proto

package cortexops

import (
	context "context"
	cli "github.com/rancher/opni/internal/codegen/cli"
	compactor "github.com/rancher/opni/internal/cortex/config/compactor"
	querier "github.com/rancher/opni/internal/cortex/config/querier"
	validation "github.com/rancher/opni/internal/cortex/config/validation"
	v1 "github.com/rancher/opni/pkg/apis/storage/v1"
	flagutil "github.com/rancher/opni/pkg/util/flagutil"
	cobra "github.com/spf13/cobra"
	pflag "github.com/spf13/pflag"
	v2 "github.com/thediveo/enumflag/v2"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	strings "strings"
)

type contextKey_CortexOps_type struct{}

var contextKey_CortexOps contextKey_CortexOps_type

func ContextWithCortexOpsClient(ctx context.Context, client CortexOpsClient) context.Context {
	return context.WithValue(ctx, contextKey_CortexOps, client)
}

func CortexOpsClientFromContext(ctx context.Context) (CortexOpsClient, bool) {
	client, ok := ctx.Value(contextKey_CortexOps).(CortexOpsClient)
	return client, ok
}

var extraCmds_CortexOps []*cobra.Command

func addCortexOpsCommand(custom *cobra.Command) {
	extraCmds_CortexOps = append(extraCmds_CortexOps, custom)
}

func BuildCortexOpsCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "ops",
		Short:             `The CortexOps service contains setup and configuration lifecycle actions for the managed Cortex cluster.`,
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
	}

	cmd.AddCommand(BuildGetClusterConfigurationCmd())
	cmd.AddCommand(BuildConfigureClusterCmd())
	cmd.AddCommand(BuildGetClusterStatusCmd())
	cmd.AddCommand(BuildUninstallClusterCmd())
	for _, extraCmd := range extraCmds_CortexOps {
		cmd.AddCommand(extraCmd)
	}
	cli.AddOutputFlag(cmd)
	return cmd
}

func BuildGetClusterConfigurationCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "get-configuration",
		Short: "Gets the current configuration of the managed Cortex cluster.",
		Long: `
HTTP handlers for this method:
- GET /configuration
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.GetClusterConfiguration(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

func BuildConfigureClusterCmd() *cobra.Command {
	in := &ClusterConfiguration{}
	cmd := &cobra.Command{
		Use:   "configure",
		Short: "Updates the configuration of the managed Cortex cluster to match the provided configuration.",
		Long: `
If the cluster is not installed, it will be configured and installed.
Otherwise, the already-installed cluster will be reconfigured.

Note: some fields may contain secrets. The placeholder value "***" can be used to
keep an existing secret when updating the cluster configuration.

HTTP handlers for this method:
- POST /configure
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.ConfigureCluster(cmd.Context(), in)
			if err != nil {
				return err
			}
			return nil
		},
	}
	cmd.Flags().AddFlagSet(in.FlagSet())
	cmd.RegisterFlagCompletionFunc("mode", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) {
		return []string{"AllInOne", "HighlyAvailable"}, cobra.ShellCompDirectiveDefault
	})
	return cmd
}

func BuildGetClusterStatusCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "status",
		Short: "Gets the current status of the managed Cortex cluster.",
		Long: `
The status includes the current install state, version, and metadata. If
the cluster is in the process of being reconfigured or uninstalled, it will
be reflected in the install state.
No guarantees are made about the contents of the metadata field; its
contents are strictly informational.

HTTP handlers for this method:
- GET /status
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			response, err := client.GetClusterStatus(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			cli.RenderOutput(cmd, response)
			return nil
		},
	}
	return cmd
}

func BuildUninstallClusterCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "uninstall",
		Short: "Uninstalls the managed Cortex cluster.",
		Long: `
Implementation details including error handling and system state requirements
are left to the cluster driver, and this API makes no guarantees about
the state of the cluster after the call completes (regardless of success).

HTTP handlers for this method:
- POST /uninstall
`[1:],
		Args:              cobra.NoArgs,
		ValidArgsFunction: cobra.NoFileCompletions,
		RunE: func(cmd *cobra.Command, args []string) error {
			client, ok := CortexOpsClientFromContext(cmd.Context())
			if !ok {
				cmd.PrintErrln("failed to get client from context")
				return nil
			}
			_, err := client.UninstallCluster(cmd.Context(), &emptypb.Empty{})
			if err != nil {
				return err
			}
			return nil
		},
	}
	return cmd
}

func (in *ClusterConfiguration) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("ClusterConfiguration", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(v2.New(&in.Mode, "DeploymentMode", map[DeploymentMode][]string{
		DeploymentMode_AllInOne:        {"AllInOne"},
		DeploymentMode_HighlyAvailable: {"HighlyAvailable"},
	}, v2.EnumCaseSensitive), strings.Join(append(prefix, "mode"), "."), "The deployment mode to use for Cortex.")
	if in.Storage == nil {
		in.Storage = &v1.StorageSpec{}
	}
	fs.AddFlagSet(in.Storage.FlagSet(append(prefix, "storage")...))
	if in.Grafana == nil {
		in.Grafana = &GrafanaConfig{}
	}
	fs.AddFlagSet(in.Grafana.FlagSet(append(prefix, "grafana")...))
	if in.Workloads == nil {
		in.Workloads = &CortexWorkloadsSpec{}
	}
	fs.AddFlagSet(in.Workloads.FlagSet(append(prefix, "workloads")...))
	if in.Cortex == nil {
		in.Cortex = &CortexConfig{}
	}
	fs.AddFlagSet(in.Cortex.FlagSet(append(prefix, "cortex")...))
	return fs
}

func (in *GrafanaConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("GrafanaConfig", pflag.ExitOnError)
	fs.SortFlags = true
	fs.BoolVar(&in.Enabled, strings.Join(append(prefix, "enabled"), "."), false, "Whether to deploy a managed Grafana instance.")
	fs.StringVar(&in.Hostname, strings.Join(append(prefix, "hostname"), "."), "", "DNS name at which Grafana will be available in the browser.")
	return fs
}

func (in *CortexWorkloadsSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("CortexWorkloadsSpec", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Distributor == nil {
		in.Distributor = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.Distributor.FlagSet(append(prefix, "distributor")...))
	fs.Lookup(strings.Join(append(prefix, "distributor", "replicas"), ".")).DefValue = "1"
	if in.Ingester == nil {
		in.Ingester = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.Ingester.FlagSet(append(prefix, "ingester")...))
	if in.Compactor == nil {
		in.Compactor = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.Compactor.FlagSet(append(prefix, "compactor")...))
	if in.StoreGateway == nil {
		in.StoreGateway = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.StoreGateway.FlagSet(append(prefix, "store-gateway")...))
	if in.Ruler == nil {
		in.Ruler = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.Ruler.FlagSet(append(prefix, "ruler")...))
	if in.QueryFrontend == nil {
		in.QueryFrontend = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.QueryFrontend.FlagSet(append(prefix, "query-frontend")...))
	fs.Lookup(strings.Join(append(prefix, "query-frontend", "replicas"), ".")).DefValue = "1"
	if in.Querier == nil {
		in.Querier = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.Querier.FlagSet(append(prefix, "querier")...))
	if in.Purger == nil {
		in.Purger = &CortexWorkloadSpec{}
	}
	fs.AddFlagSet(in.Purger.FlagSet(append(prefix, "purger")...))
	fs.Lookup(strings.Join(append(prefix, "purger", "replicas"), ".")).DefValue = "1"
	return fs
}

func (in *CortexWorkloadSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("CortexWorkloadSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.IntPtrValue(&in.Replicas), strings.Join(append(prefix, "replicas"), "."), "Number of replicas to run for this workload. Should be an odd number.")
	fs.StringSliceVar(&in.ExtraArgs, strings.Join(append(prefix, "extra-args"), "."), nil, "Any additional arguments to pass to Cortex.")
	return fs
}

func (in *CortexConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("CortexConfig", pflag.ExitOnError)
	fs.SortFlags = true
	if in.Limits == nil {
		in.Limits = &validation.Limits{}
	}
	fs.AddFlagSet(in.Limits.FlagSet(append(prefix, "limits")...))
	fs.Lookup(strings.Join(append(prefix, "limits", "ingestion-rate"), ".")).DefValue = "600000"
	fs.Lookup(strings.Join(append(prefix, "limits", "ingestion-rate-strategy"), ".")).DefValue = "local"
	fs.Lookup(strings.Join(append(prefix, "limits", "ingestion-burst-size"), ".")).DefValue = "1000000"
	fs.Lookup(strings.Join(append(prefix, "limits", "compactor-blocks-retention-period"), ".")).DefValue = "seconds:2592000"
	if in.Compactor == nil {
		in.Compactor = &compactor.Config{}
	}
	fs.AddFlagSet(in.Compactor.FlagSet(append(prefix, "compactor")...))
	if in.Querier == nil {
		in.Querier = &querier.Config{}
	}
	fs.AddFlagSet(in.Querier.FlagSet(append(prefix, "querier")...))
	fs.StringVar(&in.LogLevel, strings.Join(append(prefix, "log-level"), "."), "", "")
	return fs
}
