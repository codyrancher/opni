<script>
import LabeledSelect from '@shell/components/form/LabeledSelect';
import Tab from '@shell/components/Tabbed/Tab';
import Tabbed from '@shell/components/Tabbed';
import { cloneDeep } from 'lodash';
import { CortexOps, DryRun } from '@pkg/opni/api/opni';
import Backend from '../Backend';
import CapabilityTable from '../CapabilityTable';
import { getMetricCapabilities } from '../../utils/requests/capability';
import { getClusterStats } from '../../utils/requests';
import Grafana from './Grafana';
import { default as StorageComponent } from './Storage';

export async function isEnabled() {
  const state = (await CortexOps.service.Status()).installState;

  return state !== CortexOps.types.InstallState.NotInstalled;
}

export default {
  components: {
    Backend,
    LabeledSelect,
    Grafana,
    CapabilityTable,
    StorageComponent,
    Tab,
    Tabbed
  },

  data() {
    return {
      presets:       [],
      presetOptions: [],
      presetIndex:   0,
      capabilities:  [],
      config:        {},
    };
  },

  methods: {
    async updateStatus(capabilities = []) {
      try {
        const stats = await getClusterStats(this);

        capabilities.forEach(c => c.updateStats(stats));
      } catch (ex) {}
    },

    async loadCapabilities(parent) {
      this.capabilities = await getMetricCapabilities(parent);

      return this.capabilities;
    },

    headerProvider(headers) {
      const newHeaders = [...headers];

      newHeaders.push(...[
        {
          name:      'numSeries',
          labelKey:  'opni.tableHeaders.numSeries',
          sort:      ['numSeries'],
          value:     'numSeries',
          formatter: 'Number'
        },
        {
          name:          'sampleRate',
          labelKey:      'opni.tableHeaders.sampleRate',
          sort:          ['sampleRate'],
          value:         'sampleRate',
          formatter:     'Number',
          formatterOpts: { suffix: '/s' }
        },
        {
          name:          'provider',
          labelKey:      'opni.tableHeaders.provider',
          sort:          ['provider'],
          value:         'provider',
          formatter:     'TextWithClass',
          formatterOpts: {
            getClass(_, value) {
              return value === 'â€”' ? 'text-muted' : '';
            }
          }
        },
        {
          name:          'isLocal',
          labelKey:      'opni.tableHeaders.local',
          sort:          ['isLocal'],
          value:         'localIcon',
          formatter:     'Icon',
          width:     20
        },
      ]);

      return newHeaders;
    },

    async disable() {
      await CortexOps.service.Uninstall();
      if (this.config.cortexConfig.storage.s3?.secretAccessKey) {
        this.$set(this.config.cortexConfig.storage.s3, 'secretAccessKey', '');
      }
    },

    async save() {
      if (this.config.cortexConfig.storage.backend === 's3') {
        if (this.config.cortexConfig.storage.s3.endpoint === '') {
          throw new Error('Endpoint is required');
        }

        if (this.config.cortexConfig.storage.s3.bucketName === '') {
          throw new Error('Bucket Name is required');
        }

        if (this.config.cortexConfig.storage.s3.secretAccessKey === '') {
          throw new Error('Secret Access Key is required');
        }
      }

      if (this.config.grafana.enabled) {
        // check if hostname is set and not empty
        if (!this.config.grafana.hostname || this.config.grafana.hostname === '') {
          throw new Error('Grafana hostname is required');
        }
      }

      const newConfig = CortexOps.types.CapabilityBackendConfigSpec.fromJson(this.config);
      const activeConfig = await CortexOps.service.GetConfiguration(CortexOps.types.GetRequest.fromJson({}));
      const shouldSetConfig = activeConfig.revision.revision === 0n;

      const dryRunRequest = new CortexOps.types.DryRunRequest({
        spec:   newConfig,
        action: shouldSetConfig ? DryRun.types.Action.Set : DryRun.types.Action.Reset,
        target: DryRun.types.Target.ActiveConfiguration
      });

      const dryRun = await CortexOps.service.DryRun(dryRunRequest);

      if (dryRun.validationErrors?.length > 0) {
        throw dryRun.validationErrors;
      }

      await CortexOps.service.SetDefaultConfiguration(newConfig);

      if (shouldSetConfig) {
        await CortexOps.service.SetConfiguration(CortexOps.types.CapabilityBackendConfigSpec.fromJson({}));
      } else {
        await CortexOps.service.ResetConfiguration();
      }

      await CortexOps.service.Install();
    },

    bannerMessage(status) {
      if (status.warnings?.length > 0) {
        return `There are currently errors that need to be resolved:`;
      }

      switch (status.installState) {
      case CortexOps.types.InstallState.Uninstalling:
        return `Monitoring is currently uninstalling from the cluster. You can't make changes right now.`;
      case CortexOps.types.InstallState.Installed:
        return `Monitoring is currently installed on the cluster.`;
      default:
        return `Monitoring is currently in an unknown state on the cluster. You can't make changes right now.`;
      }
    },

    bannerState(status) {
      if (status.warnings?.length > 0) {
        return 'error';
      }

      switch (status.installState) {
      case CortexOps.types.InstallState.Uninstalling:
        return 'warning';
      case CortexOps.types.InstallState.Installed:
        return `success`;
      default:
        return `error`;
      }
    },

    isEnabled,

    async isUpgradeAvailable() {
      return await false;
    },

    async getStatus() {
      try {
        const status = (await CortexOps.service.Status());

        if (status.installState === CortexOps.types.InstallState.NotInstalled) {
          return null;
        }

        return {
          state:   this.bannerState(status),
          message: this.bannerMessage(status),
          list:     status.warnings
        };
      } catch (ex) {
        return null;
      }
    },

    async getConfig() {
      const presets = (await CortexOps.service.ListPresets()).items;

      this.$set(this, 'presets', presets);
      this.$set(this, 'presetOptions', presets.map((p, i) => ({
        label: p.metadata.displayName,
        value: i
      })));
      this.setPresetAsConfig(this.presetIndex);

      const config = JSON.parse((await CortexOps.service.GetDefaultConfiguration(new CortexOps.types.GetRequest({}))).toJsonString());

      config.cortexConfig.storage = config.cortexConfig.storage || { backend: 's3' };
      const backendField = config.cortexConfig.storage.backend;
      const clone = cloneDeep(this.config);

      this.$set(this, 'config', { ...clone, ...config });
      this.$set(this.config.cortexConfig, 'storage', { ...(clone.cortexConfig.storage || {}), ...(config.cortexConfig.storage || {}) });
      this.$set(this.config.cortexConfig.storage, backendField, { ...(clone.cortexConfig.storage?.[backendField] || {}), ...(config.cortexConfig.storage?.[backendField] || {}) });
      this.$set(this.config.cortexConfig.storage, 'backend', config.cortexConfig.storage.backend || 'filesystem');
      this.$set(this.config, 'grafana', config.grafana || { enabled: true });

      return this.config;
    },

    setPresetAsConfig(index) {
      this.$set(this, 'config', this.presets[index].spec);
    }
  },

  watch: {
    presetIndex() {
      this.setPresetAsConfig(this.presetIndex);
    }
  }
};
</script>
<template>
  <Backend
    title="Monitoring"
    :is-enabled="isEnabled"
    :disable="disable"
    :is-upgrade-available="isUpgradeAvailable"
    :get-status="getStatus"
    :get-config="getConfig"
    :save="save"
  >
    <template #editing>
      <div class="row mb-20">
        <div class="col span-12">
          <LabeledSelect v-model="presetIndex" :options="presetOptions" label="Preset" />
        </div>
      </div>
      <Tabbed :side-tabs="true">
        <Tab :weight="4" name="storage" label="Storage">
          <StorageComponent v-model="config.cortexConfig" />
        </Tab>
        <Tab :weight="3" name="grafana" label="Grafana">
          <Grafana v-model="config.grafana" :status="status" />
        </Tab>
      </Tabbed>
    </template>
    <template #details>
      <CapabilityTable :capability-provider="loadCapabilities" :header-provider="headerProvider" :update-status-provider="updateStatus" />
    </template>
  </Backend>
</template>

<style lang="scss" scoped>
::v-deep {
  .tab-container {
    position: relative;
  }
}
</style>
