// Code generated by cli_gen.go DO NOT EDIT.
// source: github.com/rancher/opni/pkg/apis/storage/v1/storage.proto

package v1

import (
	errors "errors"
	flagutil "github.com/rancher/opni/pkg/util/flagutil"
	pflag "github.com/spf13/pflag"
	v2 "github.com/thediveo/enumflag/v2"
	os "os"
	strings "strings"
)

func (in *StorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("StorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(v2.New(&in.Backend, "Backend", map[Backend][]string{
		Backend_filesystem: {"filesystem"},
		Backend_s3:         {"s3"},
		Backend_gcs:        {"gcs"},
		Backend_azure:      {"azure"},
		Backend_swift:      {"swift"},
	}, v2.EnumCaseSensitive), strings.Join(append(prefix, "backend"), "."), "Name of the storage backend to use.")
	if in.S3 == nil {
		in.S3 = &S3StorageSpec{}
	}
	fs.AddFlagSet(in.S3.FlagSet(append(prefix, "s3")...))
	if in.Gcs == nil {
		in.Gcs = &GCSStorageSpec{}
	}
	fs.AddFlagSet(in.Gcs.FlagSet(append(prefix, "gcs")...))
	if in.Azure == nil {
		in.Azure = &AzureStorageSpec{}
	}
	fs.AddFlagSet(in.Azure.FlagSet(append(prefix, "azure")...))
	if in.Swift == nil {
		in.Swift = &SwiftStorageSpec{}
	}
	fs.AddFlagSet(in.Swift.FlagSet(append(prefix, "swift")...))
	if in.Filesystem == nil {
		in.Filesystem = &FilesystemStorageSpec{}
	}
	fs.AddFlagSet(in.Filesystem.FlagSet(append(prefix, "filesystem")...))
	return fs
}

func (in *StorageSpec) RedactSecrets() {
	if in == nil {
		return
	}
	in.S3.RedactSecrets()
	in.Gcs.RedactSecrets()
	in.Azure.RedactSecrets()
	in.Swift.RedactSecrets()
}

func (in *StorageSpec) UnredactSecrets(unredacted *StorageSpec) error {
	if in == nil {
		return nil
	}
	if err := in.S3.UnredactSecrets(unredacted.GetS3()); err != nil {
		return err
	}
	if err := in.Gcs.UnredactSecrets(unredacted.GetGcs()); err != nil {
		return err
	}
	if err := in.Azure.UnredactSecrets(unredacted.GetAzure()); err != nil {
		return err
	}
	if err := in.Swift.UnredactSecrets(unredacted.GetSwift()); err != nil {
		return err
	}
	return nil
}

func (in *S3StorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("S3StorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Endpoint, strings.Join(append(prefix, "endpoint"), "."), "", "The S3 bucket endpoint. It could be an AWS S3 endpoint listed at https://docs.aws.amazon.com/general/latest/gr/s3.html or the address of an S3-compatible service in hostname:port format.")
	fs.StringVar(&in.Region, strings.Join(append(prefix, "region"), "."), "", "S3 region. If unset, the client will issue a S3 GetBucketLocation API call to autodetect it.")
	fs.StringVar(&in.BucketName, strings.Join(append(prefix, "bucket-name"), "."), "", "S3 bucket name")
	fs.StringVar(&in.SecretAccessKey, strings.Join(append(prefix, "secret-access-key"), "."), "", "\x1b[31m[secret]\x1b[0m S3 secret access key")
	fs.StringVar(&in.AccessKeyID, strings.Join(append(prefix, "access-key-id"), "."), "", "S3 access key ID")
	fs.BoolVar(&in.Insecure, strings.Join(append(prefix, "insecure"), "."), false, "If enabled, use http:// for the S3 endpoint instead of https://. This could be useful in local dev/test environments while using an S3-compatible backend storage, like Minio.")
	fs.StringVar(&in.SignatureVersion, strings.Join(append(prefix, "signature-version"), "."), "", "The signature version to use for authenticating against S3. Supported values are: v4, v2")
	if in.Sse == nil {
		in.Sse = &SSEConfig{}
	}
	fs.AddFlagSet(in.Sse.FlagSet(append(prefix, "sse")...))
	if in.Http == nil {
		in.Http = &HTTPConfig{}
	}
	fs.AddFlagSet(in.Http.FlagSet(append(prefix, "http")...))
	return fs
}

func (in *S3StorageSpec) RedactSecrets() {
	if in == nil {
		return
	}
	if in.SecretAccessKey != "" {
		in.SecretAccessKey = "***"
	}
	in.Sse.RedactSecrets()
}

func (in *S3StorageSpec) UnredactSecrets(unredacted *S3StorageSpec) error {
	if in == nil {
		return nil
	}
	if in.SecretAccessKey == "***" {
		if unredacted.GetSecretAccessKey() == "" {
			return errors.New("cannot unredact: missing value for secret field: SecretAccessKey")
		}
		in.SecretAccessKey = unredacted.SecretAccessKey
	}
	if err := in.Sse.UnredactSecrets(unredacted.GetSse()); err != nil {
		return err
	}
	return nil
}

func (in *SSEConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SSEConfig", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Type, strings.Join(append(prefix, "type"), "."), "", "Enable AWS Server Side Encryption. Supported values: SSE-KMS, SSE-S3")
	fs.StringVar(&in.KmsKeyID, strings.Join(append(prefix, "kms-key-id"), "."), "", "KMS Key ID used to encrypt objects in S3")
	fs.StringVar(&in.KmsEncryptionContext, strings.Join(append(prefix, "kms-encryption-context"), "."), "", "\x1b[31m[secret]\x1b[0m KMS Encryption Context used for object encryption. It expects a JSON formatted string.")
	return fs
}

func (in *SSEConfig) RedactSecrets() {
	if in == nil {
		return
	}
	if in.KmsEncryptionContext != "" {
		in.KmsEncryptionContext = "***"
	}
}

func (in *SSEConfig) UnredactSecrets(unredacted *SSEConfig) error {
	if in == nil {
		return nil
	}
	if in.KmsEncryptionContext == "***" {
		if unredacted.GetKmsEncryptionContext() == "" {
			return errors.New("cannot unredact: missing value for secret field: KmsEncryptionContext")
		}
		in.KmsEncryptionContext = unredacted.KmsEncryptionContext
	}
	return nil
}

func (in *HTTPConfig) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("HTTPConfig", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Var(flagutil.DurationpbValue(0, &in.IdleConnTimeout), strings.Join(append(prefix, "idle-conn-timeout"), "."), "The time an idle connection will remain idle before closing.")
	fs.Var(flagutil.DurationpbValue(0, &in.ResponseHeaderTimeout), strings.Join(append(prefix, "response-header-timeout"), "."), "The amount of time the client will wait for a servers response headers.")
	fs.BoolVar(&in.InsecureSkipVerify, strings.Join(append(prefix, "insecure-skip-verify"), "."), false, "If the client connects via HTTPS and this option is enabled, the client will accept any certificate and hostname.")
	fs.Var(flagutil.DurationpbValue(0, &in.TlsHandshakeTimeout), strings.Join(append(prefix, "tls-handshake-timeout"), "."), "Maximum time to wait for a TLS handshake. 0 means no limit.")
	fs.Var(flagutil.DurationpbValue(0, &in.ExpectContinueTimeout), strings.Join(append(prefix, "expect-continue-timeout"), "."), "The time to wait for a server's first response headers after fully writing the request headers if the request has an Expect header. 0 to send the request body immediately.")
	fs.Int32Var(&in.MaxIdleConns, strings.Join(append(prefix, "max-idle-conns"), "."), 0, "Maximum number of idle (keep-alive) connections across all hosts. 0 means no limit.")
	fs.Int32Var(&in.MaxIdleConnsPerHost, strings.Join(append(prefix, "max-idle-conns-per-host"), "."), 0, "Maximum number of idle (keep-alive) connections to keep per-host. If 0, a built-in default value is used.")
	fs.Int32Var(&in.MaxConnsPerHost, strings.Join(append(prefix, "max-conns-per-host"), "."), 0, "Maximum number of connections per host. 0 means no limit.")
	return fs
}

func (in *GCSStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("GCSStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.BucketName, strings.Join(append(prefix, "bucket-name"), "."), "", "GCS bucket name")
	fs.StringVar(&in.ServiceAccount, strings.Join(append(prefix, "service-account"), "."), "", "\x1b[31m[secret]\x1b[0m JSON representing either a Google Developers Console client_credentials.json file or a Google Developers service account key file. If empty, fallback to Google default logic.")
	return fs
}

func (in *GCSStorageSpec) RedactSecrets() {
	if in == nil {
		return
	}
	if in.ServiceAccount != "" {
		in.ServiceAccount = "***"
	}
}

func (in *GCSStorageSpec) UnredactSecrets(unredacted *GCSStorageSpec) error {
	if in == nil {
		return nil
	}
	if in.ServiceAccount == "***" {
		if unredacted.GetServiceAccount() == "" {
			return errors.New("cannot unredact: missing value for secret field: ServiceAccount")
		}
		in.ServiceAccount = unredacted.ServiceAccount
	}
	return nil
}

func (in *AzureStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("AzureStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.StorageAccountName, strings.Join(append(prefix, "storage-account-name"), "."), "", "Azure storage account name")
	fs.StringVar(&in.StorageAccountKey, strings.Join(append(prefix, "storage-account-key"), "."), "", "\x1b[31m[secret]\x1b[0m Azure storage account key")
	fs.StringVar(&in.ContainerName, strings.Join(append(prefix, "container-name"), "."), "", "Azure storage container name")
	fs.StringVar(&in.Endpoint, strings.Join(append(prefix, "endpoint"), "."), "", "Azure storage endpoint suffix without schema. The account name will be prefixed to this value to create the FQDN")
	fs.Int32Var(&in.MaxRetries, strings.Join(append(prefix, "max-retries"), "."), 0, "Number of retries for recoverable errors")
	fs.StringVar(&in.MsiResource, strings.Join(append(prefix, "msi-resource"), "."), "", "\x1b[31m[secret]\x1b[0m Azure storage MSI resource. Either this or account key must be set.")
	fs.StringVar(&in.UserAssignedID, strings.Join(append(prefix, "user-assigned-id"), "."), "", "Azure storage MSI resource managed identity client Id. If not supplied system assigned identity is used")
	if in.Http == nil {
		in.Http = &HTTPConfig{}
	}
	fs.AddFlagSet(in.Http.FlagSet(append(prefix, "http")...))
	return fs
}

func (in *AzureStorageSpec) RedactSecrets() {
	if in == nil {
		return
	}
	if in.StorageAccountKey != "" {
		in.StorageAccountKey = "***"
	}
	if in.MsiResource != "" {
		in.MsiResource = "***"
	}
}

func (in *AzureStorageSpec) UnredactSecrets(unredacted *AzureStorageSpec) error {
	if in == nil {
		return nil
	}
	if in.StorageAccountKey == "***" {
		if unredacted.GetStorageAccountKey() == "" {
			return errors.New("cannot unredact: missing value for secret field: StorageAccountKey")
		}
		in.StorageAccountKey = unredacted.StorageAccountKey
	}
	if in.MsiResource == "***" {
		if unredacted.GetMsiResource() == "" {
			return errors.New("cannot unredact: missing value for secret field: MsiResource")
		}
		in.MsiResource = unredacted.MsiResource
	}
	return nil
}

func (in *SwiftStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("SwiftStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.Int32Var(&in.AuthVersion, strings.Join(append(prefix, "auth-version"), "."), 0, "OpenStack Swift authentication API version. 0 to autodetect.")
	fs.StringVar(&in.AuthURL, strings.Join(append(prefix, "auth-url"), "."), os.Getenv("OS_AUTH_URL"), "OpenStack Swift authentication URL. ($OS_AUTH_URL)")
	fs.StringVar(&in.Username, strings.Join(append(prefix, "username"), "."), os.Getenv("OS_USERNAME"), "OpenStack Swift username. ($OS_USERNAME)")
	fs.StringVar(&in.UserDomainName, strings.Join(append(prefix, "user-domain-name"), "."), os.Getenv("OS_USER_DOMAIN_NAME"), "OpenStack Swift user's domain name. ($OS_USER_DOMAIN_NAME)")
	fs.StringVar(&in.UserDomainID, strings.Join(append(prefix, "user-domain-id"), "."), os.Getenv("OS_USER_DOMAIN_ID"), "OpenStack Swift user's domain ID. ($OS_USER_DOMAIN_ID)")
	fs.StringVar(&in.UserID, strings.Join(append(prefix, "user-id"), "."), os.Getenv("OS_USER_ID"), "OpenStack Swift user ID. ($OS_USER_ID)")
	fs.StringVar(&in.Password, strings.Join(append(prefix, "password"), "."), os.Getenv("OS_PASSWORD"), "\x1b[31m[secret]\x1b[0m OpenStack Swift API key. ($OS_PASSWORD)")
	fs.StringVar(&in.DomainID, strings.Join(append(prefix, "domain-id"), "."), os.Getenv("OS_USER_DOMAIN_ID"), "OpenStack Swift user's domain ID. ($OS_USER_DOMAIN_ID)")
	fs.StringVar(&in.DomainName, strings.Join(append(prefix, "domain-name"), "."), os.Getenv("OS_USER_DOMAIN_NAME"), "OpenStack Swift user's domain name. ($OS_USER_DOMAIN_NAME)")
	fs.StringVar(&in.ProjectID, strings.Join(append(prefix, "project-id"), "."), "", "OpenStack Swift project ID (v2,v3 auth only).")
	fs.StringVar(&in.ProjectName, strings.Join(append(prefix, "project-name"), "."), os.Getenv("OS_PROJECT_NAME"), "OpenStack Swift project name (v2,v3 auth only). ($OS_PROJECT_NAME)")
	fs.StringVar(&in.ProjectDomainID, strings.Join(append(prefix, "project-domain-id"), "."), os.Getenv("OS_PROJECT_DOMAIN_ID"), "ID of the OpenStack Swift project's domain (v3 auth only), only needed if it differs the from user domain. ($OS_PROJECT_DOMAIN_ID)")
	fs.StringVar(&in.ProjectDomainName, strings.Join(append(prefix, "project-domain-name"), "."), os.Getenv("OS_PROJECT_DOMAIN_NAME"), "Name of the OpenStack Swift project's domain (v3 auth only), only needed if it differs from the user domain. ($OS_PROJECT_DOMAIN_NAME)")
	fs.StringVar(&in.RegionName, strings.Join(append(prefix, "region-name"), "."), os.Getenv("OS_REGION_NAME"), "OpenStack Swift Region to use (v2,v3 auth only). ($OS_REGION_NAME)")
	fs.StringVar(&in.ContainerName, strings.Join(append(prefix, "container-name"), "."), "", "Name of the OpenStack Swift container to use. The container must already exist.")
	fs.Int32Var(&in.MaxRetries, strings.Join(append(prefix, "max-retries"), "."), 0, "Max number of times to retry failed requests.")
	fs.Var(flagutil.DurationpbValue(0, &in.ConnectTimeout), strings.Join(append(prefix, "connect-timeout"), "."), "Time after which a connection attempt is aborted.")
	fs.Var(flagutil.DurationpbValue(0, &in.RequestTimeout), strings.Join(append(prefix, "request-timeout"), "."), "Time after which an idle request is aborted. The timeout watchdog is reset each time some data is received, so the timeout triggers after X time no data is received on a request.")
	return fs
}

func (in *SwiftStorageSpec) RedactSecrets() {
	if in == nil {
		return
	}
	if in.Password != "" {
		in.Password = "***"
	}
}

func (in *SwiftStorageSpec) UnredactSecrets(unredacted *SwiftStorageSpec) error {
	if in == nil {
		return nil
	}
	if in.Password == "***" {
		if unredacted.GetPassword() == "" {
			return errors.New("cannot unredact: missing value for secret field: Password")
		}
		in.Password = unredacted.Password
	}
	return nil
}

func (in *FilesystemStorageSpec) FlagSet(prefix ...string) *pflag.FlagSet {
	fs := pflag.NewFlagSet("FilesystemStorageSpec", pflag.ExitOnError)
	fs.SortFlags = true
	fs.StringVar(&in.Directory, strings.Join(append(prefix, "directory"), "."), "", "Local filesystem storage directory.")
	return fs
}
